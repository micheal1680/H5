# js总结

#### 1.js的简单认识：

一个页面有三层：

1. 结构层（HTML标签完成）；
2.  修饰层（css完成）；
3. 逻辑层（js完成）；

即一个页面的内容与结构是由无数的HTML标签堆砌形成的，而这些内容的样式与布局是由无数的选择器css修饰完成的，这些内容能够执行的动作与逻辑是由js完成的。css能够做到的用js也能做到，但是能用css完成的绝不用或者尽量不用js完成，这样做才能提高页面的可用性，提高用户的用户体验。

js负责页面的逻辑，有个动作：事件。

事件三要素：

1. 事件源：你要操作的对象（DOM节点），代码表示方法为：document.querySelectors('选择器')；
2. 事件：click    input  focus  keydown    keyup；
3. 事件处理函数：事件要实现的效果需要一个函数。（这一个函数里面还可以包裹无数个函数，形成高阶函数，直到实现事件需要的效果）。

#### 2.变量类型：

代码在进行运行的时候，需要对变量进行：变量解析

变量包括：

1. number：数字类型；
2. string：字符串类型（文本类型）。格式：用引号引起来的；
3. boolean：布尔值类型。有两个值：true  false；
4. null：声明了一个变量，指向的存储空间里面没有东西，即空；
5. undefined：声明了变量，没有赋值；
6. object：对象类型；
7. function：函数类型；
8. array：数组类型；（数组也是对象的一种，因此其类型返回值是：object）

###### 重点：

Js在运行的时候，会把变量转换成它需要的数据类型；比如：

console.log('3'-'4');  //返回-1

此处是把字符串类型转换为数字类型，进行运算，结果为：-1。

#### <u>3.运算符：</u>

1. +: 加，字符串连接
2. -:减号，用于数字运算；
3. *:用于数字运算；
4. /:用于数字运算，用于数据类型转换；
5. 比较运算符：==    ===（考虑数据类型）  !=   !==  >  >=  <  <= 

#### 4.逻辑运算符：

1. &&:与，都返回true的时候才返回true;
2. ||:或，都返回false的时候才返回false
3. !:非，取反
4. 熔断机制：

#### 5.逗号运算符：

​	总是返回最后一个表达式的 结果；（重点）

#### 6.变量作用域：

1. 全局变量：定义在顶级代码里面的变量；
2. 局部变量：在函数内部声明的变量；
3. 作用域链：代码在运行的时候，会对变量进行解析==》要找到变量对应的值==》在函数内部找==》到全局里面去找

###### 变量提升：

1. 只提升声明，不提升赋值；
2. 例如：函数内部的未声明的变量，会进行变量提升，但是只提升变量声明例如：var a，但是赋值a=1不提升.

​	 我们写代码的时候尽量规避变量提升；

#### 7.函数:

对公用的功能的封装，一处定义，处处使用，方便维护；(即一个项目中可能有多个地方会使用相同的逻辑，因此将这些功能封装在函数中，哪些地方要用直接引用函数就可以)。

声明函数：

​		Function  fn(){

​			函数体；

}

​	函数后面跟上小括号表示函数的执行；（任何函数或方法（实质上也是函数）后面都必须要加上()才可以让函数执行，否则不起作用）。

###### 7.1 形参和实参

**形参**：函数名后面的小括号里面指定函数的形参，形参的作用域是局部变量，只能在函数内部使用；

实参：在调用函数的时候，提供的具体的值就是实参；

函数内部用arguments这个类数组来接收所有的实参。	

###### 7.2 函数返回值

1. Return 负责返回值；
2. 在函数里面才有return；
3. return是函数的结束标志，Return后面的代码不会执行了；
4. 函数内部必须要有return，如果没有使用return，返回undefined；

###### 7.3 自运行函数

格式：（function(){}）（）；

自运行函数可以形成一个封闭的空间，不会污染全局变量；

即相互之间不会产生不好的干扰。使用自运行函数，即使两个文件中含有相同的变量，合并后也不会相互污染。

###### 7.4 This的指向

谁调用这个方法，this就指向谁(ES6里面有个箭头函数，不适用这句话)；

This指向的是距离this最近的function的调用者（通用）

#### 8.高阶函数：

使用函数作为实参；

函数本身可以直接作为实参；

#### 9.闭包：

1. 在函数内部返回函数；
2. 形成一个镜像；
3. 引用在，空间不灭；
4. 内存消耗特别大；

#### 10.Undefined的情况：

1. 声明的变量没有赋值；

2. 函数的形参没有传递实参；

3. 使用对象未定义（不存在）的属性；

4. 如果函数没有返回值，则返回值是undefined；

#### 11.数组：

数组：是一类数据的集合；（即一个数组内的元素是同一类数据类型的元素）  

数组：就是一个类；

常用的方法和属性：

1. length：获取元素的数量；
2. pop():删除数组的最后一个元素并返回删除的元素值；
3. push():从数组的尾部开始添加元素；
4. shift()：删除数组的第一个元素;
5. unshift()：在数组的开始位置追加新的元素；
6. sort()：对数组的元素进行排序；
7. splice()：可以对数组的任意位置的元素进行增删改操作；
8. concat:连接数组；

Array.isArray():判断一个变量是否是数组。

#### 12.循环：

continue：跳出本次循环，进入下一次循环

break：跳出整个循环

#### 13.对象：

1.类：对某一类事物的定义；  人类、汽车、学生

​	他并没有指定具体的某一个人。

​	汽车：有发动机，有四个轮子，可以跑的机器；

2.对象：就是类的实例化。是真切存在的。彭朝辉。

​	对象有自己的属性和方法：

​	属性代表特征：红色、宝马；

​	方法代表动作：跑、变速；

###### 定义类的方法：

使用构造函数定义类：

1、 习惯性将类名（构造函数）首字母大写；

2、在函数内部，使用this指向当前类创建的实例化对象；

3、 使用new创建实例化对象；

其中，New的过程发生了什么：

1， 生成空白的空间，使用this指向这个空间；

2， 把构造函数内部定义的属性和方法追加到this这个对象之上；

3， 最后，返回this给前面的变量；

#### 14.定时器：

1. setTimeout：只执行一次；
2. clearTimeout：清除定时器
3. setInterval：根据指定的时间间隔不断执行；
4. clearInterval：清除定时器，需要指定定时器的id；

#### 15.原型：

1. 每一个对象都有一个和他相关的对象，这个对象我们称为是原型；
2. 原型之上的属性和方法都会被继承过来；
3. 原型给了我们一个修改构造函数的机会，我们可以通过原型给构造函数增加新的属性和方法；

构造函数的原型即prototype  和 实例化的对象的原型即__proto__ 的关系：

是完全相等的：他们两个就是指向一个内存空间，他们就是一个东西的两个地址引用。

原型链是动态继承的，实例化对象是可以动态继承类的属性和方法；

###### 重点：

This的指向发生改变的解决办法：     提前缓存；

JSON格式的数据：       就是对象类型。

#### 16.函数的劫持方法：

1. apply：接收的是数组类型参数，会直接执行当前函数
2. call:是一个一个的，会直接执行当前函数
3. bind:主要用于改变this的执行，返回函数体。

共同点：都可以改变this的指向。

#### 17.正则表达式：

正则表达式：是数据的一种匹配模式；

```js 
// globle:全局     
        var str = 'hcqyj的官网123是hqyj.com';
        // 简单的创建方法   这种模式不支持表达式（或变量），就只支持字面量（直接量）。相当于 ：对象.
        var reg = /hqyj/; //     reg :代表正则表达式，/ /内是正则表达式的值
        // var reg=/hpyj/g;  这个g表示globe表全局，即表示匹配全部的hqyj
        var r = str.match(reg);//match()是string的一个函数方法，作用是匹配。所以str.match()是匹配函数
        console.log(r);


        // 标准方式  支持表达式(或变量) ，相当于 ：对象的 []
        var a = '官网';
        var regexp = new RegExp(a);   //a是变量
        console.log(str.match(regexp));
```

对于正则表达式有很多方法：

常用的有：replace、split、exec方法